#
# Copyright The NOMAD Authors.
#
# This file is part of NOMAD. See https://nomad-lab.eu for further info.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

import datetime

from nomad_material_processing.physical_vapor_deposition import (
    PVDChamberEnvironment,
    PVDMaterialEvaporationRate,
    PVDMaterialSource,
    PVDPressure,
    PVDSourcePower,
    PVDSubstrate,
    PVDSubstrateTemperature,
    ThermalEvaporation,
    ThermalEvaporationHeater,
    ThermalEvaporationHeaterTemperature,
    ThermalEvaporationSource,
    ThermalEvaporationStep,
)
from nomad_material_processing.utils import create_archive
from structlog.stdlib import (
    BoundLogger,
)
from nomad.metainfo import (
    Package,
    Section,
    Quantity,
)
from nomad.datamodel.data import (
    EntryData,
)
from nomad.datamodel.metainfo.annotations import (
    ELNAnnotation,
)
from nomad.datamodel.metainfo.eln import (
    Substance,
)
from nomad.metainfo.metainfo import (
    Category,
)
from nomad.datamodel.data import (
    EntryDataCategory,
)

m_package = Package(name='HZB Unold Lab')

substance_translation = {
    'PbI2': 'Lead Iodide',
    'CsI': 'Cesium Iodide',
    'PbBr2': 'Lead Bromide',
    'CsBr': 'Cesium Bromide'
}


class HZBUnoldLabCategory(EntryDataCategory):
    m_def = Category(label='HZB Unold Lab', categories=[EntryDataCategory])


class HZBUnoldLabSubstance(Substance, EntryData):
    pass


class HZBUnoldLabThermalEvaporation(ThermalEvaporation, EntryData):
    '''
    Class autogenerated from yaml schema.
    '''
    m_def = Section(
        categories=[HZBUnoldLabCategory],
        links=["http://purl.obolibrary.org/obo/CHMO_0001360"],
        a_plot=[
            dict(
                x='steps/:/sources/:/material_source/rate/process_time',
                y='steps/:/sources/:/material_source/rate/rate',
            ),
            # dict(
            #     x='steps/:/sources/:/evaporation_source/temperature/process_time',
            #     y='steps/:/sources/:/evaporation_source/temperature/temperature',
            # ),
            dict(
                x='steps/:/environment/pressure/process_time',
                y='steps/:/environment/pressure/pressure',
                layout=dict(
                    yaxis=dict(
                        type='log',
                    ),
                ),
            ),
        ],
    )
    log_file = Quantity(
        type=str,
        description='''
        The log file generated by the PVD software.
        ''',
        a_eln = ELNAnnotation(
            component='FileEditQuantity'
        ),
    )

    def normalize(self, archive, logger: BoundLogger) -> None:
        '''
        The normalizer for the `HZBUnoldLabThermalEvaporation` class. Will generate and
        fill the `steps` attribute using the `log_file`.

        Args:
            archive (EntryArchive): The archive containing the section that is being
            normalized.
            logger (BoundLogger): A structlog logger.
        '''
        # import json
        # print(json.dumps(dir(archive), indent=2))
        if self.log_file:
            import pandas as pd
            import numpy as np
            with archive.m_context.raw_file(self.log_file, 'r') as fh:
                line = fh.readline().strip()
                metadata = {}
                while line.startswith('#'):
                    if ':' in line:
                        key = line.split(':')[0][1:].strip()
                        value = str.join(':', line.split(':')[1:]).strip()
                        metadata[key] = value
                    line = fh.readline().strip()
                df = pd.read_csv(fh, sep='\t')
            self.datetime = datetime.datetime.strptime(
                f'{metadata["Date"]}T{df["Time"].values[0]}',
                r'%Y/%m/%dT%H:%M:%S',
            )
            self.end_time = datetime.datetime.strptime(
                f'{metadata["Date"]}T{df["Time"].values[-1]}',
                r'%Y/%m/%dT%H:%M:%S',
            )
            self.name =  f'PVD-{metadata["process ID"]}'
            self.location = 'Berlin, Germany'
            self.lab_id = f'HZB_{metadata["operator"]}_{self.datetime.strftime(r"%Y%m%d")}_PVD-{metadata["process ID"]}'

            source_materials = {column[0]: column.split()[2] for column in df.columns if column[-1:] == 'T'}

            qcms = ['QCM1_1', 'QCM1_2', 'QCM2_1', 'QCM2_2']
            qcms_source_number = {df[qcm[:-2]+" FILMNAM"+qcm[-2:]].values[0]: qcm for qcm in qcms}
            try:
                qcms_ordered = [qcms_source_number[int(source)] for source in source_materials]
            except KeyError:
                raise ValueError("Film names do not match source names.")
            shutters = [f'{qcm[:-2]} SHTSRC{qcm[-2:]}' for qcm in qcms_ordered]
            start_times = []
            for shutter in shutters:
                switch_times = df.loc[df[shutter].diff() != 0, 'Process Time in seconds'].values
                for time in switch_times:
                    if not any(abs(t - time) < 5 for t in start_times):
                        start_times.append(time)
            start_times.append(df.iloc[-1,1])
            substances = {
                source_nr: create_archive(
                    entity=HZBUnoldLabSubstance(
                        name=substance_translation.get(
                            source_materials[source_nr],
                            source_materials[source_nr]
                        ),
                    ),
                    archive=archive,
                    file_name=f'{source_materials[source_nr]}_substance.archive.json',
                ) for source_nr in source_materials
            }
            steps = []
            depositions = 0
            for idx, time in enumerate(start_times[:-1]):
                step = df.loc[
                    (time <= df['Process Time in seconds'])
                    & (df['Process Time in seconds'] < start_times[idx + 1])
                ]
                if step.loc[:, shutters].mode().any().any():
                    depositions += 1
                    name = f'deposition {depositions}'
                elif idx == 0:
                    name = 'pre'
                else:
                    name = 'post'
                sources = []
                for source_nr in source_materials:
                    source = f'{source_nr} - {source_materials[source_nr]}'
                    material_source = PVDMaterialSource(
                        material=substances[source_nr],
                        rate=PVDMaterialEvaporationRate(
                            rate=1e-6 * step[f'{source} PV'],
                            process_time=step['Process Time in seconds'],
                            measurement_type='Quartz Crystal Microbalance',
                        ),
                    )
                    evaporation_source = ThermalEvaporationHeater(
                        temperature=ThermalEvaporationHeaterTemperature(
                            temperature=step[f'{source} T'] + 273.15,
                            process_time=step['Process Time in seconds'],
                        ),
                        power=PVDSourcePower(
                            power=step[f'{source} Aout'],
                            process_time=step['Process Time in seconds']
                        ),
                    )
                    thermal_evaporation_source = ThermalEvaporationSource(
                        name=source_materials[source_nr],
                        material_source=material_source,
                        evaporation_source=evaporation_source,
                    )
                    sources.append(thermal_evaporation_source)
                substrate = PVDSubstrate(
                    substrate=None,  # TODO: Add substrate
                    temperature=PVDSubstrateTemperature(
                        temperature=step['Substrate PV'] + 273.15,
                        process_time=step['Process Time in seconds'],
                        measurement_type='Heater thermocouple',
                    ),
                    heater='Resistive element',
                    distance_to_source=[
                        np.linalg.norm(np.array((41.54e-3, 26.06e-3, 201.12e-3)))
                    ] * 4,
                )
                environment = PVDChamberEnvironment(
                    pressure=PVDPressure(
                        pressure=step['Vacuum Pressure2'] * 1e2,
                        process_time=step['Process Time in seconds'],
                    ),
                )
                step = ThermalEvaporationStep(
                    name=name,
                    creates_new_thin_film=step.loc[:, shutters].mode().any().any(),
                    duration=start_times[idx + 1] - time,
                    sources=sources,
                    substrate=[substrate],
                    environment=environment,
                )
                steps.append(step)
            self.steps = steps


        super(HZBUnoldLabThermalEvaporation, self).normalize(archive, logger)


m_package.__init_metainfo__()
