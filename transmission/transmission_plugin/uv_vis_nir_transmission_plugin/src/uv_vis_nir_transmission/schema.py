#
# Copyright The NOMAD Authors.
#
# This file is part of NOMAD. See https://nomad-lab.eu for further info.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
from typing import (
    TYPE_CHECKING,
    Dict,
    Any,
    Callable,
    Union,
)
from nomad.datamodel.data import EntryData
from nomad.datamodel.metainfo.basesections import (
    CompositeSystem,
    Instrument,
    InstrumentReference,
    Measurement,
    MeasurementResult,
)
import numpy as np
import plotly.express as px
from nomad.metainfo import (
    Package,
    Quantity,
    SubSection,
    MEnum,
    Section,
)
from nomad.datamodel.data import (
    EntryData,
    ArchiveSection,
)

from nomad.datamodel.metainfo.annotations import (
    ELNAnnotation,
    ELNComponentEnum,
)

from nomad.datamodel.metainfo.plot import (
    PlotSection,
    PlotlyFigure,
)

from uv_vis_nir_transmission.readers import read_asc
from uv_vis_nir_transmission.utils import merge_sections, create_archive

if TYPE_CHECKING:
    from nomad.datamodel.datamodel import EntryArchive
    from structlog.stdlib import BoundLogger


m_package = Package(name='uv-vis-nir-transmission')


class TransmissionSpectrophotometer(Instrument, EntryData):
    """
    Entry section for the transmission spectrophotometer.
    """

    m_def = Section()
    serial_number = Quantity(
        type=str,
        description='instrument serial number',
        a_eln={'component': 'StringEditQuantity'},
    )
    software_version = Quantity(
        type=str,
        description='software/firmware version',
        a_eln={'component': 'StringEditQuantity'},
    )

    def normalize(self, archive: 'EntryArchive', logger: 'BoundLogger') -> None:
        """
        The normalizer for the `TransmissionSpectrophotometer` class.

        Args:
            archive (EntryArchive): The archive containing the section that is being
            normalized.
            logger (BoundLogger): A structlog logger.
        """
        super().normalize(archive, logger)


class TransmissionSample(CompositeSystem, EntryData):
    """
    Class autogenerated from yaml schema.
    """

    m_def = Section()
    name = Quantity(
        type=str,
        description='sample name',
        a_eln={'component': 'StringEditQuantity', 'label': 'sample_name'},
    )
    lab_id = Quantity(
        type=str,
        description='sample id',
        a_eln={'component': 'StringEditQuantity', 'label': 'sample_id'},
    )
    chemical_composition = Quantity(
        type=str,
        description='chemical composition',
        a_eln={'component': 'StringEditQuantity'},
    )
    length = Quantity(
        type=np.float64,
        description='length (or thickness) of the sample in mm',
        a_eln={'component': 'NumberEditQuantity'},  # "defaultDisplayUnit": "mm"},
        unit='mm',
    )
    orientation = Quantity(
        type=str,
        description='crystallographic orientation of sample',
        a_eln={'component': 'StringEditQuantity'},
    )

    def normalize(self, archive: 'EntryArchive', logger: 'BoundLogger') -> None:
        """
        The normalizer for the `TransmissionSample` class.

        Args:
            archive (EntryArchive): The archive containing the section that is being
            normalized.
            logger (BoundLogger): A structlog logger.
        """
        super(TransmissionSample, self).normalize(archive, logger)


class Accessory(ArchiveSection):
    """
    Class autogenerated from yaml schema.
    """

    m_def = Section()
    polarizer = Quantity(
        type=bool,
        description='polarizer used',
        a_eln={'component': 'BoolEditQuantity'},
    )
    aperture = Quantity(
        type=np.float64,
        description='aperture diameter',
        a_eln={'component': 'NumberEditQuantity', 'defaultDisplayUnit': 'mm'},
        unit='mm',
    )


class SlitWidth(ArchiveSection):
    """
    Class autogenerated from yaml schema.
    """

    m_def = Section()
    wavelength = Quantity(
        type=np.float64,
        description='wavelength',
        a_eln={'component': 'NumberEditQuantity', 'defaultDisplayUnit': 'nm'},
        unit='nm',
    )
    value = Quantity(
        type=np.float64,
        description='slit width',
        a_eln={'component': 'NumberEditQuantity', 'defaultDisplayUnit': 'nm'},
        unit='nm',
    )


class ChangePoint(ArchiveSection):
    m_def = Section()
    wavelength = Quantity(
        type=np.float64,
        description='wavelength',
        a_eln={'component': 'NumberEditQuantity', 'defaultDisplayUnit': 'nm'},
        unit='nm',
    )


class Monochromator(ArchiveSection):
    """
    Class autogenerated from yaml schema.
    """

    m_def = Section()
    monochromator_change_point = SubSection(
        section_def=ChangePoint,
        repeats=True,
        description='monochromator change point in nm',
    )
    slit_width = SubSection(
        section_def=SlitWidth,
        repeats=True,
    )


class Lamp(ArchiveSection):
    """
    Class autogenerated from yaml schema.
    """

    m_def = Section()
    d2_lamp = Quantity(
        type=bool,
        description='D2 lamp used',
        a_eln={'component': 'BoolEditQuantity'},
    )
    tungsten_lamp = Quantity(
        type=bool,
        description='tungsten lamp used',
        a_eln={'component': 'BoolEditQuantity'},
    )
    lamp_change_point = SubSection(
        section_def=ChangePoint,
        repeats=True,
        description='lamp change point in nm',
    )


class NIRGain(ArchiveSection):
    """
    Class autogenerated from yaml schema.
    """

    m_def = Section()
    wavelength = Quantity(
        type=np.float64,
        description='wavelength',
        a_eln={'component': 'NumberEditQuantity', 'defaultDisplayUnit': 'nm'},
        unit='nm',
    )
    value = Quantity(
        type=np.float64,
        description='value',
        a_eln={'component': 'NumberEditQuantity'},
    )


class IntegrationTime(ArchiveSection):
    """
    Class autogenerated from yaml schema.
    """

    m_def = Section()
    wavelength = Quantity(
        type=np.float64,
        description='wavelength',
        a_eln={'component': 'NumberEditQuantity', 'defaultDisplayUnit': 'nm'},
        unit='nm',
    )
    value = Quantity(
        type=np.float64,
        description='value',
        a_eln={'component': 'NumberEditQuantity', 'defaultDisplayUnit': 's'},
        unit='s',
    )


class Detector(ArchiveSection):
    """
    Class autogenerated from yaml schema.
    """

    m_def = Section()
    module = Quantity(
        type=MEnum(['three detector module', '150-mm integrating sphere']),
        description='detector module',
        a_eln={'component': 'RadioEnumEditQuantity'},
    )
    detector_change_point = SubSection(
        section_def=ChangePoint,
        repeats=True,
        description='detector change point in nm',
    )
    nir_gain = SubSection(
        section_def=NIRGain,
        repeats=True,
    )
    integration_time = SubSection(
        section_def=IntegrationTime,
        repeats=True,
    )


class Attenuator(ArchiveSection):
    """
    Class autogenerated from yaml schema.
    """

    m_def = Section()
    sample = Quantity(
        type=int,
        description='sample beam attenuation in %',
        a_eln={'component': 'NumberEditQuantity', 'minValue': 0, 'maxValue': 100},
    )
    reference = Quantity(
        type=int,
        description='reference beam attenuation in %',
        a_eln={'component': 'NumberEditQuantity', 'minValue': 0, 'maxValue': 100},
    )


class TransmissionSettings(ArchiveSection):
    """
    Class autogenerated from yaml schema.
    """

    m_def = Section()
    ordinate_type = Quantity(
        type=MEnum(['%T', 'A']),
        description='ordinate type',
        a_eln={'component': 'RadioEnumEditQuantity'},
    )
    sample_beam_position = Quantity(
        type=MEnum(['Front', 'Rear']),
        description='sample beam position',
        a_eln={'component': 'RadioEnumEditQuantity'},
    )
    common_beam_mask = Quantity(
        type=int,
        description='common beam mask',
        a_eln={'component': 'NumberEditQuantity', 'minValue': 0, 'maxValue': 100},
    )
    common_beam_depolarizer = Quantity(
        type=bool,
        description='common beam depolarizer',
        a_eln={'component': 'BoolEditQuantity'},
    )
    polarizer_angle = Quantity(
        type=np.float64,
        description='polarizer angle in Â°',
        a_eln={'component': 'NumberEditQuantity'},
        unit='degrees',
    )
    accessory = SubSection(
        section_def=Accessory,
    )
    monochromator = SubSection(
        section_def=Monochromator,
    )
    lamp = SubSection(
        section_def=Lamp,
    )
    detector = SubSection(
        section_def=Detector,
    )
    attenuator = SubSection(
        section_def=Attenuator,
    )


class UVVisNirTransmissionResult(MeasurementResult):
    """
    Class autogenerated from yaml schema.
    """

    m_def = Section()
    type = Quantity(
        type=str,  # MEnum(["Transmission", "Absorbance"]),
        description='type of measurement',
        # a_eln={"component": "RadioEnumEditQuantity"},
    )
    transmittance = Quantity(
        type=np.float64,
        description='Transmittance percentage %T',
        # a_eln={"component": "NumberEditQuantity"},
        shape=['*'],
        unit='dimensionless',
        a_plot={'x': 'wavelength', 'y': 'transmittance'},
    )
    absorbance = Quantity(
        type=np.float64,
        description='Absorbance A',
        shape=['*'],
        unit='dimensionless',
        a_plot={'x': 'wavelength', 'y': 'absorbance'},
    )
    wavelength = Quantity(
        type=np.float64,
        description='wavelength',
        # a_eln={"component": "NumberEditQuantity", "defaultDisplayUnit": "nm"},
        shape=['*'],
        unit='nm',
        a_plot={'x': 'wavelength', 'y': 'transmittance'},
    )

    def generate_plots(self) -> list[PlotlyFigure]:
        """
        Generate the plotly figures for the `UVVisNirTransmissionResult` section.

        Returns:
            list[PlotlyFigure]: The plotly figures.
        """
        line_linear = px.line(
            x=self.wavelength.magnitude,
            y=self.transmittance.magnitude,
        )
        line_linear.update_layout(
            title='Transmission vs wavelength',
            xaxis_title='Wavelength (nm)',
            yaxis_title='Transmission',
            xaxis=dict(
                fixedrange=False,
            ),
            yaxis=dict(
                fixedrange=False,
            ),
        )
        figure = [
            PlotlyFigure(
                label='Linear Plot',
                figure=line_linear.to_plotly_json(),
            ),
        ]
        return figure

    def normalize(self, archive: 'EntryArchive', logger: 'BoundLogger') -> None:
        """
        The normalizer for the `UVVisNirTransmissionResult` class.

        Args:
            archive (EntryArchive): The archive containing the section that is being
            normalized.
            logger (BoundLogger): A structlog logger.
        """
        super(UVVisNirTransmissionResult, self).normalize(archive, logger)


class UVVisTransmission(Measurement):
    """
    Class autogenerated from yaml schema.
    """

    m_def = Section()
    method = Quantity(
        type=str,
        default='UV-Vis-NIR Transmission',
    )
    user = Quantity(
        type=str,
        description='analyst name from header in ascii',
        a_eln={'component': 'StringEditQuantity'},
    )
    results = Measurement.results.m_copy()
    results.section_def = UVVisNirTransmissionResult

    transmission_settings = SubSection(
        section_def=TransmissionSettings,
    )


class ELNUVVisTransmission(UVVisTransmission, PlotSection, EntryData):
    """
    Entry class for UVVisTransmission.
    """

    data_file = Quantity(
        type=str,
        description='*.asc Data file containing the UV-Vis-NIR transmission spectrum',
        a_eln=ELNAnnotation(
            component=ELNComponentEnum.FileEditQuantity,
        ),
    )

    def get_read_write_functions(self) -> tuple[Callable, Callable]:
        """
        Method for getting the correct read and write functions for the current data file.

        Returns:
            tuple[Callable, Callable]: The read, write functions.
        """
        if self.data_file.endswith('.asc'):
            return read_asc, self.write_transmission_data
        return None, None

    def create_instrument_entry(
        self, data_dict: Dict[str, Any], archive: 'EntryArchive', logger: 'BoundLogger'
    ) -> InstrumentReference:
        """
        Method for creating the instrument entry. Returns a reference to the created
        instrument.

        Args:
            data_dict (Dict[str, Any]): The dictionary containing the instrument data.
            archive (EntryArchive): The archive containing the section.
            logger (BoundLogger): A structlog logger.

        Returns:
            InstrumentReference: The instrument reference.
        """
        instrument = TransmissionSpectrophotometer(
            name=data_dict['instrument_name'],
            serial_number=data_dict['instrument_serial_number'],
            software_version=data_dict['instrument_firmware_version'],
        )
        instrument.normalize(archive, logger)

        logger.info('Created instrument entry.')
        m_proxy_value = create_archive(instrument, archive, 'instrument.archive.json')

        return InstrumentReference(reference=m_proxy_value)

    def get_instrument_reference(
        self, data_dict: Dict[str, Any], archive: 'EntryArchive', logger: 'BoundLogger'
    ) -> Union[InstrumentReference, None]:
        """
        Method for getting the instrument reference.
        Looks for an existing instrument with the given serial number.
        If found, it returns a reference to this instrument.
        If no instrument is found, logs a warning, creates a new entry for the instrument
        and returns a reference to this entry.
        If multiple instruments are found, it logs a warning and returns None.

        Args:
            data_dict (Dict[str, Any]): The dictionary containing the instrument data.
            archive (EntryArchive): The archive containing the section.
            logger (BoundLogger): A structlog logger.

        Returns:
            Union[InstrumentReference, None]: The instrument reference or None.
        """
        from nomad.search import search

        serial_number = data_dict['instrument_serial_number']
        api_query = {
            'search_quantities': {
                'id': (
                    'data.serial_number#uv_vis_nir_transmission.schema.'
                    'TransmissionSpectrophotometer'
                ),
                'str_value': f'{serial_number}',
            },
        }
        search_result = search(
            owner='visible',
            query=api_query,
            user_id=archive.metadata.main_author.user_id,
        )

        if not search_result.data:
            logger.warn(
                f'No "TransmissionSpectrophotometer" instrument found with the serial '
                f'number "{serial_number}".'
            )
            return self.create_instrument_entry(data_dict, archive, logger)

        if len(search_result.data) > 1:
            logger.warn(
                f'Multiple "TransmissionSpectrophotometer" instruments found with the '
                f'serial number "{serial_number}". Please select it manually.'
            )
            return None

        entry = search_result.data[0]
        upload_id = entry['upload_id']
        entry_id = entry['entry_id']
        m_proxy_value = f'../uploads/{upload_id}/archive/{entry_id}#/data'

        return InstrumentReference(reference=m_proxy_value)

    def write_transmission_data(
        self,
        transmission_dict: Dict[str, Any],
        archive: 'EntryArchive',
        logger: 'BoundLogger',
    ) -> None:
        """
        Populate `UVVisTransmission` section with the data from the transmission_dict.

        Args:
            transmission_dict (Dict[str, Any]): A dictionary with the transmission data.
            archive (EntryArchive): The archive containing the section.
            logger (BoundLogger): A structlog logger.
        """
        self.user = transmission_dict['analyst_name']

        result = UVVisNirTransmissionResult(
            wavelength=transmission_dict['measured_wavelength'],
            type=transmission_dict['ordinate_type'],
        )
        if transmission_dict['ordinate_type'] == 'A':
            result.absorbance = transmission_dict['measured_ordinate']
        elif transmission_dict['ordinate_type'] == '%T':
            result.transmittance = transmission_dict['measured_ordinate']
        else:
            logger.warn(f"Unknown ordinate type '{transmission_dict['ordinate']}'.")
        result.normalize(archive, logger)

        lamp = Lamp(
            d2_lamp=transmission_dict['is_d2_lamp_used'],
            tungsten_lamp=transmission_dict['is_tungsten_lamp_used'],
        )
        for wavelength in transmission_dict['lamp_change_wavelength']:
            lamp.lamp_change_point.append(ChangePoint(wavelength=wavelength))
        lamp.normalize(archive, logger)

        detector = Detector(
            module=transmission_dict['detector_module'],
        )
        for wavelength, value in transmission_dict['detector_NIR_gain'].items():
            detector.nir_gain.append(
                NIRGain(
                    wavelength=wavelength,
                    value=value,
                )
            )
        for wavelength, value in transmission_dict['detector_integration_time'].items():
            detector.integration_time.append(
                IntegrationTime(
                    wavelength=wavelength,
                    value=value,
                )
            )
        for wavelength in transmission_dict['detector_change_wavelength']:
            detector.detector_change_point.append(ChangePoint(wavelength=wavelength))
        detector.normalize(archive, logger)

        monochromator = Monochromator()
        for wavelength, slit_width in transmission_dict[
            'monochromator_slit_width'
        ].items():
            monochromator.slit_width.append(
                SlitWidth(
                    wavelength=wavelength,
                    value=slit_width,
                )
            )
        for wavelength in transmission_dict['monochromator_change_wavelength']:
            monochromator.monochromator_change_point.append(
                ChangePoint(wavelength=wavelength)
            )
        monochromator.normalize(archive, logger)

        attenuator = Attenuator(
            sample=transmission_dict['sample_attenuation_percentage'],
            reference=transmission_dict['reference_attenuation_percentage'],
        )

        transmission_settings = TransmissionSettings(
            ordinate_type=transmission_dict['ordinate_type'],
            sample_beam_position=transmission_dict['sample_beam_position'],
            common_beam_mask=transmission_dict['common_beam_mask_percentage'],
            common_beam_depolarizer=transmission_dict['is_common_beam_depolarizer_on'],
            polarizer_angle=transmission_dict['polarizer_angle'],
            lamp=lamp,
            detector=detector,
            monochromator=monochromator,
            attenuator=attenuator,
        )
        transmission_settings.normalize(archive, logger)

        instrument_reference = self.get_instrument_reference(
            transmission_dict, archive, logger
        )
        if instrument_reference is not None:
            instruments = [instrument_reference]
        else:
            instruments = []

        transmission = UVVisTransmission(
            results=[result],
            transmission_settings=transmission_settings,
            instruments=instruments,
        )
        merge_sections(self, transmission, logger)

    def normalize(self, archive: 'EntryArchive', logger: 'BoundLogger'):
        """
        The normalize function of the `UVVisTransmission` section.

        Args:
            archive (EntryArchive): The archive containing the section that is being
            normalized.
            logger (BoundLogger): A structlog logger.
        """
        if self.data_file is not None:
            read_function, write_function = self.get_read_write_functions()
            if read_function is None or write_function is None:
                logger.warn(
                    f'No compatible reader found for the file: "{self.data_file}".'
                )
            else:
                with archive.m_context.raw_file(self.data_file) as file:
                    transmission_dict = read_function(file.name, logger)
                write_function(transmission_dict, archive, logger)
        super().normalize(archive, logger)

        if not self.results:
            return

        self.figures = self.results[0].generate_plots()

    # def normalize(self, archive, logger: BoundLogger) -> None:
    #     """
    #     The normalizer for the `UVVisTransmission` class.

    #     Args:
    #         archive (EntryArchive): The archive containing the section that is being
    #         normalized.
    #         logger (BoundLogger): A structlog logger.
    #     """
    #     super(UVVisTransmission, self).normalize(archive, logger)


m_package.__init_metainfo__()
